# 为什么我们需要动态规划

对于动态规划来说，一定有其适用的范围和条件，比如将二维的面积问题转化为边长问题再使用DP进行计算，因此我们需要获悉动态规划的适用范围再来进行实用

# 背包问题

## 01背包问题

假设我们有一个容量为 *C* 的背包，和 *n* 件物品，每件物品都有重量 *w_i* 和价值 *v_i*。目标是选择一些物品装入背包，使得在不超过背包容量的前提下，背包中的物品价值总和最大化。

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= c; j++) {
        if (j < w[i - 1]) {
            dp[i][j] = dp[i - 1][j];
        } else {
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);
        }
    }
}

//一维简化版：

for (int i = 1; i <= n; i++) {
        for (int j = c; j >= w[i - 1]; j--) {
            dp[j] = max(dp[j], dp[j - w[i - 1]] + v[i - 1]);
    }
}
```

**在01背包问题的一位滚动数组简化中，容量要使用倒序遍历**:radioactive:，使得第 *i* 件物品的状态仅于第 *i-1* 件物品有关

若采用正序，在当前迭代过程中，某些尚未使用的 `dp[j]` 会被当前物品的更新覆盖，从而影响后续计算。举例来说，假设我们正序遍历时正在更新容量为 *j = 5* 时的最大价值，而当前物品重量为 *w[i] = 3*，那么我们会使用 `dp[5-3] = dp[2]` 来计算。但如果我们已经在当前物品的迭代中更新了 `dp[2]`，那么它已经是新一轮的值，而不是上一轮的值，计算结果会出错。

## 完全背包问题

```cpp
for (int i = 1; i <= n; i++) {
        for (int j = w[i - 1]; j <= c; j--) {
            dp[j] = max(dp[j], dp[j - w[i - 1]] + v[i - 1]);
    }
}
```

**在完全背包问题的一位滚动数组简化中，容量则使用正序遍历**:radioactive:，程序会充分考虑第 i 件物品之前的子状态的最优解，使其可以选择多个同一物品



