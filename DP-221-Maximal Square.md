Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, *find the largest square containing only* `1`'s *and return its area*.


```cpp
class Solution {
   public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int ans = 0;
        int n = matrix.size(), m = matrix[0].size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (matrix[i - 1][j - 1] == '1')
                    dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                ans = max(dp[i][j], ans);
            }
        }
        return ans * ans;
    }
};
```

这题的核心和难点是如何解决判断**选定区域是否为正方形**的问题，朴素的想法是每遇到一个1区域时对上下左右进行判断，但这样的想法局限性很强，仅通过上下左右判断相当于每次遇到1时就要建立一个涵盖1的最大矩形边长来进行判断，时间和空间复杂度太高；或者暴力遍历图形中的每一个正方形，同样也是时间复杂度过高

面对这种二维的最优问题，我们可以通过动态规划的思想来求解，构造一个动态规划表，其中dp\[ i ][ j ]表示以( i , j )为右下角的最大正方形的边长。这样的话，如果能找到递推关系，就可以逐步计算每个位置的边长，然后找出最大的那个。

> 对我自己来说，面对这个问题首先暴露了一个思维局限性。即题目中最终所要求的答案是面积，我就试图一直在直接求出面积的角度上死磕，根本没有分解题目，将正方形面积的求解转化为求解正方形边长并使用动态规划来达成这一目的的思维方式:sob:。jyy在课件上也提到过，找到问题正确的切入点，就可以简化问题。以分而治之的思路去解决问题，正是作为一个计算机科班学生应具有的学科素养

回到题目，对于正方形最大边长的求法也十分简单，对矩形值为1点来说，只要根据三点（上部，左部，左上部）中最小的正方形长度，便可推导出该点最小正方形边长的大小:yum:

- 若三点为（1，1，1）、（2，2，2）... 该点为正方形的右下点，最终边长在此基础上+1
- 若三点为（1，1，0），（2，2，1）... 该点无法成为正方形右下点，会根据最小值+1

以此类推，可获悉整个matrix中正方形的最大边长，进行平方即可获得面积
